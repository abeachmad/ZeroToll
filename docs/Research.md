Browser Support for Stateless 7702 Smart Accounts with MetaMask Kit
Yes – it’s technically possible to use MetaMask’s Smart Accounts Kit in a pure browser frontend (Vite/Next.js) with Stateless 7702 smart accounts and gasless transactions via a paymaster. However, there are some important caveats and partial support limitations to be aware of:
•	Bundler/Polyfill Compatibility: The MetaMask Smart Accounts Kit is built on Node tools (Viem, etc.), so older Create React App setups often needed manual Node polyfills (Buffer, crypto, etc.) in Webpack 5[1][2]. MetaMask themselves note CRA is deprecated and recommend using Vite for new Web3 apps due to fewer bundler issues[3]. In practice, developers have reported smoother integration with Next.js and Vite (which handle ESM and polyfills better) compared to vanilla CRA.
•	Stateless 7702 Account Support: MetaMask’s kit does support creating a Stateless7702 smart account object in your dapp code[4]. This represents an EOA upgraded via EIP-7702 to behave like a smart contract account[5]. Important: The kit itself doesn’t perform the upgrade on chain – you must already have upgraded the user’s EOA to a smart account for Implementation.Stateless7702 to work[6][7]. In other words, the EIP-7702 “authorization” transaction (which sets the EOA’s contract code pointer) must be done beforehand.
•	MetaMask Extension’s Role: Currently, MetaMask Extension v12.20+ can handle the EIP-7702 upgrade natively, but it deliberately does not expose signing the 7702 authorization to web dapps (for security/phishing reasons). MetaMask uses an internal signEIP7702Authorization method (with a whitelisted delegator contract address) that is not accessible via window.ethereum[8][9]. This means your dapp cannot programmatically trigger the 7702 upgrade via the kit or an EIP-712 signature – MetaMask blocks that route[10][11]. Instead, MetaMask expects the user to upgrade through the wallet’s own UI prompts.
•	User Upgrade Flow: In practice, MetaMask will prompt the user within the extension to “Switch to Smart Account” when needed. This can happen either actively (user toggles a setting in MetaMask) or passively when a dapp action requires it[12][13]. For example, if your dapp tries to batch multiple token transfers or use a paymaster (features requiring smart account), MetaMask detects it and shows a “Use smart account” prompt[14][15]. Upon user approval, MetaMask signs and sends the EIP-7702 transaction internally (pointing the EOA to MetaMask’s StatelessDeleGator contract at 0x63c0...32B)[16][17]. This is fully client-side – no backend needed – but it’s controlled by MetaMask’s extension UI, not your code. New MetaMask users may even have smart accounts auto-enabled by default (the first 7702 upgrade happens seamlessly during their first qualifying transaction)[18][19].
•	Gasless via Paymaster: MetaMask Smart Accounts do support gas sponsorship (paymasters) once the account is upgraded. The kit’s examples show integrating third-party paymaster APIs (e.g. Pimlico, ZeroDev) and passing a paymaster client into the bundler call[20][21]. In a pure frontend, you can use Viem’s createPaymasterClient pointing to a service’s RPC endpoint (with API key) and include that in the sendUserOperation request[22][23]. This means your dapp can initiate gasless user ops from the browser, and the paymaster service (Pimlico, etc.) handles actual gas payment off-chain. No custom backend is required beyond the paymaster API. For instance, MetaMask’s docs show sending a gasless ERC-20 transfer on Sepolia by simply supplying a paymaster client to bundlerClient.sendUserOperation()[24][25] – the user’s smart account pays 0 ETH, with the paymaster sponsoring fees.
•	Partial Limitations: One limitation today is that the initial stateless upgrade cannot be dapp-automated (as noted). Teams building dapps around 7702 have had to work within this. For example, developers at Ember (VibeKit/Ember Vaults) noted in Oct 2025 that “EIP-7702 upgrade prompts from a dapp appear client-disabled” and delegation signing was blocked, forcing them to do those steps on the backend or via MetaMask UI[26][27]. MetaMask acknowledged this and has been routing developers to built-in flows[28][29]. In short, Stateless 7702 is supported in MetaMask, but only through MetaMask’s guided UX. Your frontend can detect if an account is smart or not and prompt the user accordingly (or just attempt a batch transaction and let MetaMask pop up its dialog).
•	Hybrid vs. Stateless: It’s worth noting that using the kit with Hybrid smart accounts (4337 contract accounts) doesn’t face the same restriction – you could deploy a contract wallet via your dapp code (user signs a normal tx to deploy it) and then use a bundler. But with pure stateless 7702, the upgrade step is the guarded part. Once upgraded, using the smart account (batching calls, sponsoring gas) works in-browser with the kit/Viem like any other AA flow.
Examples of Projects Implementing 7702 + MetaMask + Paymasters
Despite the early limitations, a few public projects have successfully demoed the full stack (Stateless7702 + MetaMask extension + paymaster + browser UI):
•	MetaMask’s 7702 Readiness Dapp (Vite): MetaMask open-sourced a test dApp called “7702-Readiness”[30] that runs entirely in the browser (built with Vite/React). It allows users to upgrade an EOA to a smart account (EIP-7702), then submit batch transactions and even downgrade back to an EOA[31]. The live demo (7702-readiness.vercel.app) guides the user through connecting MetaMask and clicking “Upgrade” – which triggers the MetaMask extension’s internal upgrade prompt. After upgrading (on Sepolia or Gnosis Chain, for example), the dapp lets the user send multiple sub-transactions in one go[30]. This project shows that a purely client-side app can leverage MetaMask’s 7702 support, as long as MetaMask itself handles the upgrade UI. The repo’s README confirms it demonstrates the end-to-end flow with MetaMask on supported chains[32]. (No backend; uses MetaMask and the chain’s bundlers).
•	QuickNode’s Token Sweeper dApp (Next.js): QuickNode published an example batch swap dApp that uses EIP-7702 under the hood to combine many token approvals/swaps into one transaction[33][34]. It’s a Next.js (React) frontend using Wagmi + Viem, and it connects to MetaMask (or any 7702-capable wallet). When the user selects multiple “dust” tokens to swap, the dApp calls the 7702 delegator to batch all approvals and swaps atomically. If the user’s MetaMask isn’t yet smart, MetaMask will prompt to upgrade on the fly. The entire flow (fetching balances, getting DEX quotes, then sending one userOperation with a paymaster) is done in the browser with no custom backend – QuickNode’s APIs and Infura/Pimlico’s bundlers are used for data and gas sponsorship[35][36]. The code is open-source[37][38] and even a live demo is available[39]. It showcases gasless transactions: the guide explicitly notes using 7702 to avoid “ten separate approvals and swaps” – instead doing one batched tx[40]. The Token Sweeper dApp uses MetaMask extension for signing; the Next.js app itself orchestrates the batch and calls QuickNode’s paymaster add-on. This confirms a real web UI can implement stateless 7702 + paymaster successfully in production.
•	Uniswap’s Web App (Production use): Uniswap has integrated support for 7702 smart accounts in its wallet products. In the web app context, when a user with MetaMask tries to do an “Approve+Swap” in one go, MetaMask will offer the “Use smart account” option[13]. Uniswap’s docs note that their mobile/extension wallet will prompt existing EOAs to delegate when using smart features[41][42]. In practice, many users have seen MetaMask’s pop-up when using Uniswap to batch approve and swap – this is exactly the stateless account + paymaster flow at work (Uniswap even has its own 7702 delegator contract[43][44]). The key point is that Uniswap demonstrates 7702 working entirely via front-end + MetaMask, with no user crypto moved or new address needed (the EOA simply “mounts” Uniswap’s smart wallet code temporarily). Gas abstraction is also enabled – e.g. paying fees in token or having a sponsor – though MetaMask’s default flow still has the user pay in ETH unless a paymaster is integrated. Uniswap’s solution could involve their own relayer sponsoring gas for certain transactions, but details aren’t public. Regardless, it’s a live example of stateless 7702 used in-browser at scale.
•	Community Projects & Hackathons: Several hackathon projects have explored MetaMask 7702 + paymasters. For example, Ambire Wallet’s “Simple 7702 account” and Openfort’s smart account were built to be EIP-7702 compatible (Ambire even wrote that 7702 allows “gasless transactions (sponsored gas, paying in ERC-20 tokens)”[45]). These wallets are separate from MetaMask, but they prove out the paymaster concept. On the MetaMask side, their Monad Dev Cook-Off hackathon (Sep 2025) featured teams building automated trading “vaults” using MetaMask Smart Accounts with delegations and gas sponsorship. One such team (Ember) built automation vaults where a backend agent could execute trades on behalf of a user’s stateless account (after the user signed a delegation) – this required MetaMask’s kit + paymaster + extension. They succeeded on the backend, but as noted, hit the client-side signing restriction[46][26]. This underscores that the full browser-based flow is still emerging – some projects offload the initial 7702 authorization to a backend script or ask users to click MetaMask’s UI as a one-time step.
Bottom Line: MetaMask’s Smart Accounts Kit can indeed be used in a purely front-end stack (Vite, Next.js) to create stateless EIP-7702 smart accounts and send gasless (sponsored) transactions. Projects like MetaMask’s own demo dApp[30] and QuickNode’s Token Sweeper[37][47] show it working end-to-end in the browser. The key is that the MetaMask extension itself must handle the upgrade signature – which it does via built-in prompts, since it won’t let dapps directly request that signature for security[10][11]. Once upgraded, your dapp can freely use the kit to batch operations and attach a paymaster for gas fees[20][48]. No part of the flow requires a Node.js backend aside from calling external APIs (bundler services, etc.), which can be done from the browser.
Current limitations: The only partial support issue is the user experience around upgrading and delegating – developers cannot fully automate it and must rely on MetaMask’s UX or out-of-band setup. Additionally, MetaMask’s stateless account is EOA-specific (they only allow their official delegator contract by default[17]), so if a user had upgraded via a different wallet’s contract, MetaMask won’t recognize it[49]. But with MetaMask’s own flow, all advanced features (batching, multi-call, paymasters, session keys via ERC-7710/7715, etc.) are supported in-browser[50][4]. In fact, MetaMask’s delegator contract explicitly supports “gas sponsorship” (paymasters) and multi-mode execution[51][52], so the foundation for truly gasless web UX is there. As of late 2025, we’re seeing the first real dapps leverage this: a user can visit a website, connect MetaMask, one-click a complex action, and MetaMask handles upgrading their account and using a paymaster to pay gas – all without the user needing any ETH on that account[53][54]. This is a big leap in Web3 UX, and it’s happening with entirely front-end code plus MetaMask’s Smart Accounts infrastructure.
Sources:
•	MetaMask Smart Accounts Kit docs on Stateless 7702 support[4][55] and gas sponsorship with paymasters[20][48].
•	MetaMask Help Center & GoPlus security article explaining how 7702 upgrades are initiated only via MetaMask UI (not web signatures)[8][10] and user prompts for “Use smart account”[14][13].
•	MetaMask forum discussions confirming delegation/7702 requests are blocked for external dapps (must use internal flow)[28][26].
•	Example repos: MetaMask’s 7702 Readiness test dapp (browser-based)[30] and QuickNode’s Token Sweeper (Next.js + MetaMask)[56][57], both implementing stateless 7702 with paymasters in the frontend.
•	Uniswap & Ambire documentation showing real-world usage of EIP-7702 for batch tx and sponsored gas[43][45].
________________________________________
[1] [2] [3] Bundler Polyfill Issues - Webpack 5 | MetaMask developer documentation
https://docs.metamask.io/embedded-wallets/troubleshooting/webpack-issues/
[4] [5] [50] MetaMask Smart Accounts | MetaMask developer documentation
https://docs.metamask.io/smart-accounts-kit/concepts/smart-accounts/
[6] [7] [55] Create a smart account | MetaMask developer documentation
https://docs.metamask.io/smart-accounts-kit/guides/smart-accounts/create-smart-account/
[8] [9] [10] [11] [12] [13] [16] [17] Understanding EIP-7702 Phishing Attacks: A Comprehensive Guide to Protection Strategies for Wallets | by GoPlus Security | Medium
https://goplussecurity.medium.com/understanding-eip-7702-phishing-attacks-a-comprehensive-guide-to-protection-strategies-for-wallets-8e8372e3d5ea
[14] [15] [18] [19] [49] Switch to or revert from a smart account in MetaMask | MetaMask Help Center
https://support.metamask.io/configure/accounts/switch-to-or-revert-from-a-smart-account
[20] [21] [22] [23] [24] [25] [48] Send a gasless transaction | MetaMask developer documentation
https://docs.metamask.io/smart-accounts-kit/guides/smart-accounts/send-gasless-transaction/
[26] [27] [46] Client-side interaction with delegations. Blocker for 7702 workflows? - Extension - MetaMask
https://community.metamask.io/t/client-side-interaction-with-delegations-blocker-for-7702-workflows/30871
[28] [29] Unable to sign delegations with Metamask Delegation Toolkit - Developer Discussion - MetaMask
https://community.metamask.io/t/unable-to-sign-delegations-with-metamask-delegation-toolkit/30521
[30] [31] [32] GitHub - MetaMask/7702-Readiness: This test dapp allows you to test the 7702/5792 functionality of MetaMask.
https://github.com/MetaMask/7702-Readiness
[33] [34] [35] [36] [40] How to Build an ERC-20 Batch Swap dApp Using EIP-7702 | Quicknode Guides
https://www.quicknode.com/guides/ethereum-development/dapps/erc-20-batch-swap-dapp-using-eip-7702
[37] [38] [39] [47] [56] [57] Token Sweeper: EIP-7702 Batch Swap | Quicknode Sample App Library
https://www.quicknode.com/sample-app-library/token-sweeper-eip-7702
[41] [42] [43] [44] [53] [54] Smart Wallets and Delegation – Uniswap Labs
https://support.uniswap.org/hc/en-us/articles/36391987158797-Smart-Wallets-and-Delegation
[45] Ambire: The EIP-7702 Wallet for a Better Web3
https://blog.ambire.com/eip-7702-wallet/
[51] [52] GitHub - Arvolear/awesome-eip-7702-delegations: A curated list of awesome EIP-7702 delegation destinations.
https://github.com/Arvolear/awesome-eip-7702-delegations

--------------------------------------------------------------------
MetaMask EIP-7702 Support on Sepolia and Polygon Amoy Testnets
Supported Networks for Stateless Smart Accounts (EIP-7702)
MetaMask does support EIP-7702 “Stateless” smart accounts on both Ethereum Sepolia and Polygon Amoy testnets. These networks are explicitly listed among MetaMask’s supported networks for Smart Accounts in official documentation[1]. In fact, MetaMask’s help center confirms that smart account functionality (which relies on EIP-7702 and related standards) is available on Sepolia and Amoy, alongside other testnets like Polygon Mumbai, Base Sepolia, etc.[2]. This means users and developers can use MetaMask’s smart account features (account abstraction capabilities) on those test chains.
Upgrading EOAs to Stateless 7702 Accounts on Sepolia & Amoy
MetaMask’s Smart Accounts Kit allows developers to create or upgrade an EOA into a “Stateless 7702” smart account on supported networks. The toolkit includes an implementation type specifically for EIP-7702 delegated accounts (Implementation.Stateless7702), representing an EOA upgraded with a stateless delegator contract[3]. In MetaMask’s quickstart examples, Sepolia is used to demonstrate the upgrade: the guide walks through generating a 7702 authorization and sending a special transaction to attach the smart contract code to the EOA on Sepolia[4][5]. Polygon Amoy is also supported in the same way (as indicated by the supported networks list), so developers can perform the identical flow on Amoy. Essentially, using the Smart Accounts Kit or CLI, one can call getSmartAccountsEnvironment(chainId) for Sepolia or Amoy to retrieve MetaMask’s delegator contract address on those networks, then sign a 7702 authorization and include it in a transaction to upgrade the account. After this one-time “authorization” transaction (which costs a small gas fee), the EOA becomes a MetaMask smart account on that testnet.
MetaMask extension (browser wallet) can handle this upgrade natively on these testnets as well. With MetaMask v12.20+, whenever a DApp requests a capability that requires a smart account (e.g. an atomic batch transaction or paying gas in an ERC-20 token) on Sepolia or Amoy, the extension will prompt the user to “switch to a smart account.” Confirming this triggers MetaMask to automatically include the EIP-7702 authorization in the next transaction, upgrading the EOA on-the-fly[6]. The user doesn’t have to manually run scripts – MetaMask seamlessly does the 7702 upgrade in the background when needed (after user approval). This works on Sepolia and Polygon Amoy just as on Ethereum mainnet or other supported chains, since MetaMask’s UI knows these are supported testnets[2]. The account remains the same address (still an EOA for regular uses) but now has code delegated to MetaMask’s smart contract. Users can also proactively enable or disable the smart account per network in MetaMask’s settings at any time[7][8].
Bundler Availability on Sepolia and Amoy
Bundlers compatible with MetaMask are operational on both Sepolia and Polygon Amoy, so developers are not limited to running a local bundler. MetaMask’s infrastructure (Infura, powered by Pimlico’s bundler) has ERC-4337 bundler RPC endpoints enabled on Sepolia and Amoy among other networks[9]. This means that once an account is upgraded, MetaMask (or any AA SDK using Infura) can send UserOperations on those testnets through a public bundler service. For example, Infura’s docs list “Ethereum (Sepolia)” and “Polygon (Amoy)” as networks where the eth_sendUserOperation and related bundler JSON-RPC methods are active[9]. In practice, when MetaMask submits a UserOp (after the 7702 upgrade) on Sepolia or Amoy, it will use Infura’s bundler behind the scenes – no custom setup needed by the user.
There are also third-party bundler services that support these testnets. For instance, Candide (a bundler provider) includes Polygon Amoy (chain 80002) and Sepolia (chain 11155111) in its supported endpoints[10]. Similarly, Pimlico’s own bundler supports Sepolia/Amoy as noted in their chain list[11][12]. Developers testing EIP-4337 or EIP-7702 flows on these networks have successfully used such services, indicating that the bundler infrastructure is in place. In summary: you do not need to restrict yourself to a local bundler on Sepolia or Amoy – the standard network bundlers used by MetaMask’s kit or others are available and have been used for 7702 Smart Account operations on those testnets.
Paymasters and Gas Sponsorship on These Testnets
The paymaster functionality (gas fee sponsorship or paying gas in ERC-20) is also available on Sepolia and Amoy, though with some caveats. The MetaMask Smart Accounts Kit allows configuring a Paymaster when sending UserOps, and infrastructure like Pimlico provides paymaster services on testnets. In fact, MetaMask’s developer docs include a tutorial demonstrating an ERC-20 paymaster on Sepolia: it shows how to use Pimlico’s API on Sepolia (chain 11155111) so that a smart account can pay fees in USDC instead of ETH[13][14]. This confirms that paymasters are technically supported on Sepolia (and by extension on Amoy, since both use Pimlico/Infura). Using a paymaster involves pointing the bundler client to a paymaster RPC and providing a paymaster context (e.g. the token address for an ERC-20 gas payment), which the toolkit supports. Developers have reported successful gas-sponsored transactions on these testnets by using third-party paymasters (e.g. sponsoring user operations with stablecoins via Pimlico on Sepolia).
Within MetaMask’s extension, the availability of built-in paymaster support is limited. MetaMask’s wallet API exposes a capability flag for paymasterService (gas sponsorship), but as of late 2025 this was only enabled by default on certain networks (Base mainnet was one early example)[15]. On most other networks – especially testnets like Sepolia or Amoy – MetaMask will not automatically offer to pay your gas via a paymaster by itself. In other words, the “pay gas in any token” feature is not yet universally active on testnets through the extension UI. Users need to have native testnet ETH/MATIC to cover fees, unless a DApp explicitly integrates a paymaster service. The infrastructure does exist (Pimlico’s paymaster on Sepolia/Amoy), but MetaMask won’t inject it on its own for testnet users. A DApp developer, however, could use the Smart Accounts Kit or Wallet API to call wallet_sendTransaction or wallet_sendUserOperation with a paymaster, and MetaMask would route that to the bundler appropriately. This requires the DApp to have a paymaster sponsor (as shown in the MetaMask kit tutorial with Pimlico).
TL;DR on paymasters: Yes, you can do gas-sponsored UserOps on Sepolia/Amoy using compatible paymasters (Pimlico, etc.), but MetaMask’s extension doesn’t provide free gas on those networks by default – it must be set up by the developer. The paymasterService capability is technically part of MetaMask’s API, just not broadly enabled in the consumer UI for testnets yet.
MetaMask Extension Behavior and Limitations
The MetaMask browser extension can complete the EIP-7702 upgrade and submit UserOps on Sepolia and Amoy, with a user-friendly flow. Once upgraded, your account’s transactions on these networks can be processed as UserOperations via the bundler. MetaMask’s Help Center confirms that after switching to a smart account, your transactions will still feel the same in the wallet, but under the hood they utilize the smart account when a DApp calls for features like batching[6][16]. The extension uses MetaMask’s delegator contract (deployed on each network) as the target for EIP-7702 delegation.
However, there are a few important limitations/considerations:
•	MetaMask only supports its own delegator implementation for 7702: If an EOA was upgraded using a different smart account contract (for example, another wallet’s EIP-7702 implementation), MetaMask will not recognize it as a “MetaMask Smart Account.” The support docs state that currently “we only support smart account functionality for our own Delegator smart contract”, so you’d need to redo the upgrade via MetaMask’s prompt or toolkit to use MetaMask’s AA features[17]. In practice, MetaMask’s Stateless 7702 account on Sepolia/Amoy uses a specific contract address (their StatelessDeleGator implementation) that the wallet trusts[18]. The toolkit retrieves this address for you, ensuring you upgrade to the correct contract.
•	Bundler and EntryPoint requirements: Both Sepolia and Amoy have the standard EntryPoint contract (v0.7/v0.8) deployed and used by bundlers[19][20]. MetaMask’s bundler support on these networks implies the EntryPoint is configured and running. If you’re running tests on a local network or a very new chain, you’d need an EntryPoint and bundler, but for Sepolia/Amoy this is already taken care of by Infura/Pimlico. The MetaMask kit uses Pimlico’s default EntryPoint addresses per network behind the scenes. No special client is needed – any ERC-4337 bundler compatible with the EntryPoint on those testnets will work with MetaMask.
•	Paymaster support is not fully plug-and-play in UI: As discussed, while MetaMask’s system can work with paymasters, the extension won’t automatically offer gas sponsorship on Sepolia/Amoy. Users should ensure they have some test ETH (Sepolia ETH or Polygon Amoy POL) to cover the one-time upgrade transaction and any UserOps unless a DApp they use has arranged a paymaster. This is a current limitation on user experience – likely to improve as the ecosystem matures.
•	Reliability and “beta” status: Both Sepolia and Amoy are testnets, so infrastructure can occasionally be flaky. For example, PolygonScan labels EIP-7702 authorization transactions as “Beta” features on Amoy explorers, since the standard is new. Generally, the flows are functional, but developers might encounter intermittent issues (e.g. a bundler not accepting UserOps if its mempool is down). MetaMask’s inclusion of these networks in official support implies reasonable confidence, but expect typical testnet caveats (occasional resets, lower traffic volumes, etc.).
•	MetaMask Mobile compatibility: The question focused on the browser extension, but note that MetaMask Mobile (v7.52+) also supports smart accounts on these networks[21]. The process is similar – the mobile app will prompt for upgrade when needed. Just ensure “Show test networks” is enabled for Sepolia/Amoy in settings. All remarks about bundlers and paymasters apply equally to mobile since it uses the same backend services.
In conclusion, MetaMask’s Smart Accounts (EIP-7702) are fully supported on Sepolia and Polygon Amoy. You can upgrade accounts on those testnets through MetaMask’s kit or the wallet UI, and then execute account abstraction flows (batched transactions, sponsored gas, etc.). Both Infura/Pimlico and third-party providers run bundlers on these networks, so UserOperations can be submitted without running your own infrastructure[9]. Paymasters can be used (e.g. Pimlico’s USDC paymaster on Sepolia[13]), though MetaMask doesn’t natively sponsor testnet gas. No significant network-specific roadblocks have been reported – the main requirement is using MetaMask’s approved delegator contract for the upgrade. Once that’s done, the MetaMask extension can indeed complete 7702 upgrades and send UserOps on Sepolia and Amoy just as on other supported chains, giving developers a sandbox to build and test advanced Account Abstraction features.
Sources:
•	MetaMask Developer Docs – Supported Networks (Smart Accounts Kit)[1]; Smart Account Quickstart (EIP-7702 on Sepolia)[4][5]; Smart Accounts Concepts[3]
•	MetaMask Help Center – Smart Accounts availability and network list[2]; Upgrading an EOA in MetaMask UI[6][17]
•	Infura/MetaMask Infura Docs – Bundler RPC support on Sepolia & Amoy[9]
•	Candide Docs – Bundler supported testnets (Sepolia, Amoy)[10]
•	MetaMask Tutorial – Using an ERC-20 Paymaster on Sepolia[13][14]
•	Pimlico Docs – Supported Chains (Sepolia, Polygon Amoy)[11][12] and EIP-7702 Overview/FAQ[22][23].
________________________________________
[1] Supported networks | MetaMask developer documentation
https://docs.metamask.io/smart-accounts-kit/get-started/supported-networks/
[2] [6] [7] [8] [16] [17] [21] Switch to or revert from a smart account in MetaMask | MetaMask Help Center
https://support.metamask.io/configure/accounts/switch-to-or-revert-from-a-smart-account
[3] MetaMask Smart Accounts | MetaMask developer documentation
https://docs.metamask.io/smart-accounts-kit/concepts/smart-accounts/
[4] [5] [18] EIP-7702 quickstart | MetaMask developer documentation
https://docs.metamask.io/smart-accounts-kit/get-started/smart-account-quickstart/eip7702/
[9] [19] [20] Bundler methods (ERC-4337) | MetaMask developer documentation
https://docs.metamask.io/services/concepts/bundler/
[10] Candide's Bundler Supported Networks | Candide
https://docs.candide.dev/wallet/bundler/rpc-endpoints/
[11] [12] Supported Chains | Pimlico Docs
https://docs.pimlico.io/guides/supported-chains
[13] [14] Use an ERC-20 paymaster with a smart account | MetaMask developer documentation
https://docs.metamask.io/tutorials/use-erc20-paymaster/
[15] kelche (@kelcheone) / Posts / X
http://x.com/kelcheone
[22] [23] EIP-7702 | Pimlico Docs
https://docs.pimlico.io/guides/eip7702

-----------------------------------------------------------

Combining EIP-7702 and ERC-4337 for Gasless dApp Interaction via MetaMask
Overview: EIP-7702 + ERC-4337 Integration
EIP-7702 (Stateless Smart Accounts) and ERC-4337 (Account Abstraction) are complementary standards that together enable existing Externally Owned Accounts (EOAs) to gain smart-contract capabilities without changing the account address[1][2]. In practice, EIP-7702 allows an EOA (like a MetaMask wallet address) to “delegate some executions to a piece of code” (an implementation contract) while the private key retains ultimate control[1]. ERC-4337, on the other hand, provides the infrastructure (User Operations, Bundlers, EntryPoint contract, Paymasters, etc.) for smart accounts to execute batched and sponsored transactions without modifying the consensus layer[3][2]. Combining them means an existing MetaMask EOA can be upgraded in-place to a smart account (via EIP-7702) and then use the ERC-4337 flow to interact with dApps gaslessly. The user keeps their familiar EOA address but gains “superpowers” like atomic batch transactions and gas abstraction (paying gas in alternative tokens or via sponsorship)[4][5].
In this solution, we leverage MetaMask’s latest Smart Accounts support (which implements EIP-7702 for EOAs) together with an ERC-4337 bundler and Pimlico’s paymaster service for gas sponsorship. This setup works in-browser with the MetaMask extension (no custom backend required) and is compatible with Ethereum Sepolia and Polygon Amoy testnets (both of which support EIP-7702 and 4337 in MetaMask’s toolkit)[6].
Upgrading an EOA to a Stateless 7702 Smart Account
1. Mechanism of EIP-7702 “Stateless” Upgrade: EIP-7702 introduces a new transaction type (type 0x04) often called a “set code” transaction[7]. This transaction contains an authorization_list – essentially a signed instruction that authorizes the EOA to adopt the code of a specific implementation contract[8][9]. In simpler terms, the EOA is mapped to a smart contract’s code without deploying a separate contract for that user. Under the hood, the EOA’s code is set to a tiny proxy that delegate-calls into the chosen implementation contract (designated by its address)[10][11]. This delegator contract contains the logic that enables smart-account features (batching, custom validation, etc.). The code persists until the user authorizes a different implementation or revokes it, so the EOA continuously behaves like a smart contract account after the upgrade[12][13].
2. MetaMask’s Delegation Framework: MetaMask uses EIP-7702 to grant “smart” capabilities to your existing account without changing its address or moving funds[14][15]. When you “switch to a smart account” in MetaMask, your EOA is pointed to a specific MetaMask Delegator contract on that network[16][14]. For example, MetaMask’s toolkit references an EIP7702StatelessDeleGator implementation – a stateless delegator contract that does not store any signer keys on-chain (it simply uses the EOA’s own signature for validation)[17][18]. This design keeps the upgrade lightweight and secure, as the EOA’s private key remains the sole source of truth for authorizing actions.
3. Upgrade Procedure: Upgrading an EOA involves creating and signing the EIP-7702 authorization, then submitting a transaction that attaches the code to the EOA: - Sign the Authorization: The wallet must produce a signature authorizing the mapping to the implementation contract. In MetaMask’s toolkit (which uses the Viem library), this is done via signAuthorization({ account, contractAddress, executor: "self" }), where contractAddress is the Delegator’s address[19]. The signature is over the tuple (chain_id, contract_address, nonce, ...) per EIP-7702 specs[9]. Note: This signing step requires wallet support for the 7702 authorization scheme. MetaMask’s extension internally handles this when you confirm the upgrade prompt, but there is currently no standard JSON-RPC method exposed for dapps to call directly[18]. (MetaMask’s docs confirm that signAuthorization “does not support JSON-RPC accounts” – i.e. you cannot call it on the injected provider in the browser)[18]. Thus, the upgrade typically must be initiated through MetaMask’s UI itself or via MetaMask’s SDK/Smart Accounts Kit. - Submit the Set-Code Transaction: The signed authorization cannot be executed alone; it must be included in a special transaction to actually set the EOA’s code on-chain[20]. MetaMask automates this when you approve the switch. Under the hood, it sends a transaction with an authorizationList containing your signature, and with to: set to a dummy address (zero address) and empty data[21]. Including the authorization in the tx signals the network (or bundler) to assign the delegator code to your EOA. MetaMask’s interface rolls the small gas cost for this into the next transaction you sign[22] – so the first smart-account action you perform triggers the upgrade and pays a one-time fee (e.g. on Sepolia, this is a minimal ETH cost).
After this one-time upgrade, your MetaMask account remains an EOA (you still control it with your private key/SRP) but it now has a smart contract “robot” attached that can execute advanced behaviors on your behalf[23][15]. Crucially, the address stays the same and your funds never move – the EOA is simply enhanced, not replaced[14]. You can even revert the account back to a “plain” EOA later (MetaMask lets you disable smart account mode per network, which essentially sends another authorization to drop the code)[24][25].
4. Network Support: Ensure the target networks have EIP-7702 enabled. As of late 2025, Ethereum mainnet and Sepolia support EIP-7702, and Polygon’s new Amoy testnet has support as well[26][6]. (Polygon Amoy replaced Mumbai and is account-abstraction ready.) MetaMask’s Smart Accounts Kit explicitly supports Sepolia and Polygon Amoy for 7702 smart accounts[6]. If you attempt the upgrade on a network that isn’t prepared, MetaMask won’t prompt or will error. Always test on the intended networks (Sepolia, Amoy) where the delegator contracts and entry point are deployed.
Using ERC-4337 UserOperations with the Upgraded Account
Once the EOA is upgraded via 7702, it effectively behaves as an ERC-4337 Smart Account. The Delegator contract code that MetaMask attaches is ERC-4337-compatible, meaning it implements the standard functions (like validateUserOp) needed to work with the ERC-4337 EntryPoint and bundlers[27][28]. The account can now accept User Operations instead of regular transactions:
•	UserOperation Flow: When a dApp action is initiated, instead of calling eth_sendTransaction in the normal way, the dApp (or a middleware) can construct a UserOperation object representing the desired transaction(s). The userOp.sender field is set to the EOA’s address (the upgraded account)[29]. This UserOperation contains all needed info: one or more target contract calls (batched), desired gas limits and fees, and an empty or placeholder paymasterAndData (if using a paymaster to sponsor gas). The bundler will fill in certain fields and forward it to the EntryPoint contract on-chain.
•	Signing & Validation: The signature in the UserOperation must prove that the account owner approves the operation. In this stateless 7702 setup, the EOA’s private key is still the signing key. MetaMask’s smart account contract will verify the signature by e.g. using ecrecover to ensure the sig matches the EOA’s address (since no other persistent state holds a separate key)[1][28]. MetaMask extension will handle prompting the user and producing the signature for the UserOp. In practice, the MetaMask Smart Accounts Kit uses Viem to sign the UserOp hash via the EOA’s key behind the scenes. When using the kit or Wagmi’s sendCalls, MetaMask may prompt you to “Sign a User Operation” or similar, which is analogous to confirming a transaction but off-chain. This signed user op is then ready to be sent to a bundler.
•	Constructing a UserOperation: You can use MetaMask’s Smart Accounts Kit (JavaScript SDK) or other 4337 client libraries to build and dispatch user ops. For example, using the Smart Accounts Kit with Viem:
•	First, create a MetaMaskSmartAccount instance representing your upgraded EOA. For a 7702 account, you’d specify Implementation.Stateless7702 and provide the EOA’s address and a signer. If you’re in a browser context with MetaMask, you can configure Viem to use the injected provider as a signer (e.g. via createWalletClient with the MetaMask provider)[30][31]. This allows the kit to request signatures from MetaMask rather than an in-app private key. (The kit’s docs illustrate usage with raw keys for simplicity, but in a real dApp you’d integrate with the user’s wallet.)
•	Next, set up a connection to a bundler. We will use Pimlico’s bundler service, which provides RPC endpoints for various chains. For instance, on Sepolia (chain ID 11155111) you can use https://api.pimlico.io/v2/11155111/rpc as the bundler URL[32]. Configure a bundler client in Viem: createBundlerClient({ client: publicClient, transport: http(<Pimlico RPC>) })[32]. This client will be used to send the user op.
•	Now you can craft the UserOperation by specifying the desired calls. For example, to batch two contract interactions or an approve-then-swap sequence, you provide an array of calls with each call’s target address, value, and calldata. The kit (via Viem’s sendUserOperation) accepts these and will include them in the UserOp structure[33][34]. You also set maxFeePerGas and maxPriorityFeePerGas for the bundler’s fee market[35] (often these can be set to 1 wei on testnets just to satisfy the fields, since the user isn’t directly paying).
•	Finally, call the bundler client’s sendUserOperation({...}) with the account, calls, fees, and (if applicable) a paymaster (more on this next)[36][37]. The kit will take care of including the account’s initCode if the smart account contract needed deployment. In the Stateless 7702 case, no deployment is needed (your EOA already has code after the upgrade). MetaMask’s kit knows the account is “deployed” as soon as 7702 is active. So the first user op doesn’t need an initCode (unlike other 4337 accounts) – it goes straight to execution.
The bundler will package your UserOp into a transaction to the EntryPoint contract. The EntryPoint then calls into your EOA (now a smart account contract) to run validateUserOp and then execute the batched calls[29]. Because the EOA’s code delegate-calls the implementation, it will use your EOA’s context for state changes (though the 7702 delegator is stateless by design, meaning it doesn’t use storage – it just passes through to called contracts). After execution, the bundler (or paymaster) pays the gas fee to the miner, and your dApp actions are completed on-chain.
Key capabilities achieved: With 7702+4337, you can now do things like one-click multi-call transactions (e.g. approve + swap in a single atomic action) and gasless interactions for users who have zero ETH. The EOA can even pay gas in ERC-20 tokens or have a third party sponsor the gas, which improves UX dramatically[38][39]. Next, we integrate Pimlico to handle gas sponsorship.
Gasless Transactions via Pimlico’s Paymaster
To allow gasless dApp interactions, we use a Paymaster, which is a special contract (or service) under ERC-4337 that pays for the user’s gas on their behalf[40][41]. Pimlico provides a managed paymaster service along with their bundler, so developers can easily sponsor users’ operations. Here’s how to integrate it:
•	Configure Pimlico Paymaster: Sign up with Pimlico to obtain an API key, which is required to use their endpoint. In your dApp code, you’ll create a Paymaster client for Viem. This is typically done with createPaymasterClient({ transport: http("https://api.pimlico.io/v2/<chainId>/rpc?apikey=<YOUR-APIKEY>") })[42]. For Sepolia, <chainId> is 11155111; for Polygon Amoy testnet, use the Amoy chain ID (e.g. 80002). Pimlico’s documentation will confirm the exact RPC URL for Amoy (likely https://api.pimlico.io/v2/80002/rpc with your key).
•	Sending UserOp with Paymaster: When calling sendUserOperation via the bundler client, you pass the paymaster client in the options (e.g. { paymaster: paymasterClient })[36][37]. The MetaMask Smart Accounts Kit (through Viem) will then interact with the Pimlico service: the bundler will request a paymaster signature from Pimlico to cover the transaction’s gas. Pimlico’s paymaster typically checks your account’s API balance or any policy you set (for testnets, they may sponsor freely up to certain limits). If approved, the bundler will attach paymasterAndData to the UserOp, containing Pimlico’s paymaster address and a valid signature, indicating the paymaster will pay for this UserOp’s gas[43].
•	Result: The user operation is sent to the EntryPoint with a paymaster attached. At execution time, the EntryPoint will charge the gas fees to the paymaster’s balance (instead of the user’s address), achieving a gas-free experience for the end-user[44]. From the dApp’s perspective, the user was able to sign and send a transaction without needing ETH on that network. For example, a MetaMask user on Sepolia with 0 ETH could still interact with a dApp (swap tokens, mint an NFT, etc.) because Pimlico’s paymaster sponsored the gas in ETH.
•	Multi-network Support: Pimlico supports numerous chains. Ensure you use the correct chain ID in their endpoint for Sepolia vs. Polygon Amoy. Both networks are supported by MetaMask’s kit and Pimlico’s infrastructure. Also note that MetaMask Smart Accounts support gas sponsorship out-of-the-box – you can use any paymaster service (Pimlico, ZeroDev, etc. or even a custom one) by providing the paymaster client in the UserOp submission[43][45]. We choose Pimlico here for its ease of use.
At this point, the MetaMask wallet (with the upgraded EOA) is creating UserOps that the Pimlico bundler+paymaster executes. The dApp can thus let users interact completely gaslessly in the browser. MetaMask’s UI remains nearly the same for the user (they see a signature request instead of a gas confirmation, but otherwise it’s transparent). Behind the scenes, the combination of 7702 and 4337 made it possible to have an EOA executing smart contract logic and a paymaster covering the fees.
Limitations and Considerations
While this setup is cutting-edge, there are a few important limitations and potential workarounds to highlight:
•	MetaMask Extension Support for 7702 Signing: As mentioned, MetaMask’s extension does not currently expose a direct RPC method for signing the EIP-7702 authorization or for initiating the upgrade via code. The MetaMask UI must prompt the user to switch to a smart account, or the developer must use MetaMask’s SDK which can trigger the prompt internally[22][46]. In practice, if your dApp tries to use 7702 features (e.g. batching via EIP-5792 sendCalls or a 4337 UserOp) on a supported network, MetaMask will detect it and prompt the user to “Enable smart account” for that network[47][22]. New MetaMask users (v12.20+) may have smart accounts auto-enabled by default[48][49], but for existing accounts you should handle the case where the user hasn’t upgraded. A workaround for developers is to educate the user (e.g. “You’ll be asked to upgrade your account for gasless transactions”) and rely on MetaMask’s flow. It’s not possible to programmatically sign the authorizationList using the injected ethereum provider because walletClient.signAuthorization is not available for JSON-RPC wallets[18]. If needed, advanced developers could use a backend or script with the user’s private key to pre-sign (not recommended) or use MetaMask’s Wallet API/SDK which might have a method to request the upgrade.
•	Paymaster Capability in MetaMask: The MetaMask extension’s native support for paymaster-sponsored transactions (EIP-5792 paymasterService) is currently limited. MetaMask has introduced a capabilities detection (via EIP-5792 Wallet Request APIs) where dApps can query if the wallet supports gas sponsorship on a given chain[50]. As of now, MetaMask only advertises paymasterService support on certain networks (Base was one early network with full support)[51]. On Sepolia or Polygon testnet, the MetaMask extension might report paymasterService.supported: false – meaning if you attempt to call wallet_sendCalls with a paymaster URL, MetaMask might not handle it internally. Workaround: Use an external approach as we did – by directly invoking the bundler via a library. For example, libraries like Wagmi and thirdweb allow passing a paymasterService URL into their sendCalls function when capabilities indicate support[52][53]. If MetaMask doesn’t support it natively (capability not ready), these libraries will often do the heavy lifting themselves (i.e. assemble the UserOp and call the bundler URL directly, similar to our MetaMask kit approach). In our MetaMask Smart Accounts Kit flow, we explicitly provided the Pimlico endpoints and did not rely on MetaMask extension to supply a paymaster – this is the recommended approach until MetaMask fully supports paymaster RPC calls on all networks. Always check capabilities?.[chainId]?.paymasterService?.supported if using EIP-5792; if false, you know you must manually handle the paymaster flow[50][54].
•	Signature and Security Considerations: The 7702 Delegator contract is stateless and relies on your EOA’s signatures for every operation. Ensure the user’s MetaMask is up-to-date and that they trust the implementation contract being used. MetaMask by default uses its vetted delegator contract, so that part is safe. But one risk noted in the ecosystem is phishing contracts – a malicious dApp could try to get a user to upgrade to an unknown implementation contract. MetaMask mitigates this by only prompting upgrades to known contracts in-wallet[55]. Developers should not attempt to swap out the implementation to a custom one without user consent, as that defeats the security model.
•	Deployment and Execution Gas: For Stateless 7702 accounts, there is no separate contract deployment (the EOA itself is the contract once upgraded). This saves gas and is why 7702 can be cheaper than deploying a full 4337 smart wallet[56]. However, note that each batch execution via 7702+4337 will still incur some overhead (EntryPoint execution, etc.). Paymasters like Pimlico may impose limits or fees for sponsorship. It’s wise to test gas costs on Sepolia/Amoy – e.g. a batch of two ERC-20 transfers might consume more gas through the AA flow than a single normal transaction, but it’s sponsored by the paymaster. Make sure to abide by any policies (Pimlico might require the user op’s target calls to be whitelisted or might charge your account in stablecoins off-chain for the gas). On testnets, these services are often free within reason.
•	Network-specific quirks: Sepolia and Polygon Amoy are both evolving testbeds. Sepolia closely mirrors Ethereum’s features (so 7702 and 4337 are live there). Polygon’s Amoy testnet uses POL as the gas token and is intended to replace Mumbai[57]. Ensure your MetaMask is connected to the correct chain ID (Amoy is chain ID 80002, which you may need to add to MetaMask manually if not pre-configured). The EntryPoint contract address may differ per network; MetaMask’s kit and Pimlico’s bundler will usually default to the correct one if the chain is recognized. (Sepolia and Polygon PoS typically use the standard EntryPoint v0.6 or v0.7 deployment – Pimlico and MetaMask handle this internally.)
•	Delegation Patterns if Needed: In some cases, developers have used an intermediate relayer or “delegation” account pattern to accommodate wallet limitations. For example, if a wallet couldn’t directly sign a user op, one might forward a request to a backend that orchestrates the user op (with the user’s signature on the target calls). With MetaMask’s current tooling, this isn’t necessary for our scenario – the Smart Accounts Kit and Pimlico service together handle everything client-side. But it’s good to know that MetaMask also supports a Delegation API (ERC-7710/7715) for granting third-parties permission to act on the account[16][58]. If, say, MetaMask extension lacked a feature, one could in theory delegate certain operations to a backend service. In our gasless scenario, though, a simpler approach is as described: treat MetaMask as a signing oracle and use the bundler/paymaster externally. This keeps the user fully in control and requires no guardians or off-chain private keys (aside from the paymaster’s).
In summary, by upgrading the user’s MetaMask EOA to a Stateless 7702 smart account and using ERC-4337 UserOps, we can achieve one-click gasless interactions on Sepolia and Polygon Amoy. MetaMask’s Smart Accounts Kit (or the emerging EIP-5792 sendCalls RPC) makes it possible to construct batch operations in the browser, and Pimlico’s paymaster sponsors the gas fees so the user doesn’t need ETH. Just be mindful of the current limitations: you will rely on MetaMask’s internal upgrade prompt (since direct signing of the 7702 auth isn’t exposed), and you’ll manually integrate the paymaster since MetaMask’s extension might not natively handle it on these networks. With these considerations handled, your dApp can provide a smooth Web3 UX where MetaMask users on testnets can interact freely without worrying about gas, all while keeping their familiar accounts and gaining new smart-account powers.
Sources:
•	MetaMask Support – “What is a smart account” (overview of EIP-7702 benefits)[16][14]
•	MetaMask Support – “Switch to a smart account in MetaMask” (upgrade UX and EOA remains same address)[22][59]
•	MetaMask Smart Accounts Dev Docs – Stateless 7702 account definition[60]; EIP-7702 Quickstart steps[18][20]
•	Openfort Blog – “EIP-7702 Deep Dive” (explanation of set-code tx and 4337 integration)[8][27]
•	Reddit Q&A – Difference between EIP-4337 and EIP-7702 (EOA delegation vs new smart wallet)[1][2]
•	MetaMask Dev Docs – Sending gasless UserOps with paymaster (Pimlico example)[32][42]
•	Pimlico Docs – External Wallets & Capabilities (detecting paymasterService support in wallet)[50][54]
________________________________________
[1] [2] [3] EIP-7702 vs EIP-4337: What's the difference regarding Account Abstraction? : r/ethereum
https://www.reddit.com/r/ethereum/comments/1hrmo2k/eip7702_vs_eip4337_whats_the_difference_regarding/
[4] [5] [14] [15] [16] [23] [38] [39] [58] What is a smart account | Account Abstraction in MetaMask | MetaMask Help Center
https://support.metamask.io/configure/accounts/what-is-a-smart-account
[6] Supported networks | MetaMask developer documentation
https://docs.metamask.io/smart-accounts-kit/get-started/supported-networks/
[7] [8] [9] [10] [11] [12] [13] [27] [28] [29] [44] EIP-7702 Deep Dive: Transforming Smart EOAs with ERC4337
https://www.openfort.io/blog/eip-7702-with-erc-4337
[17] [18] [19] [20] [21] [33] [35] EIP-7702 quickstart | MetaMask developer documentation
https://docs.metamask.io/smart-accounts-kit/get-started/smart-account-quickstart/eip7702/
[22] [24] [25] [46] [47] [48] [49] [55] [59] Switch to or revert from a smart account in MetaMask | MetaMask Help Center
https://support.metamask.io/configure/accounts/switch-to-or-revert-from-a-smart-account/
[26] [52] [53] [56] Next-gen Smart Accounts with EIP-7702
https://blog.thirdweb.com/changelog/next-gen-smart-accounts/
[30] [31] Create a smart account | MetaMask developer documentation
https://docs.metamask.io/smart-accounts-kit/guides/smart-accounts/create-smart-account/
[32] [34] [36] [37] [42] [43] [45] Send a gasless transaction | MetaMask developer documentation
https://docs.metamask.io/smart-accounts-kit/guides/smart-accounts/send-gasless-transaction/
[40] [41] [60] MetaMask Smart Accounts | MetaMask developer documentation
https://docs.metamask.io/smart-accounts-kit/concepts/smart-accounts/
[50] [54] Batch / sponsor transactions for an external wallets | Pimlico Docs
https://docs.pimlico.io/guides/eip7702/external
[51] What does EIP-7702 mean for YOU? Part 2 -- DApp Developers
https://docs.zerodev.app/blog/7702-for-dapps
[57] Amoy - Thirdweb
https://thirdweb.com/polygon-amoy-testnet

----------------------------------------------------------------

Viem vs. Wagmi for MetaMask Smart Accounts (EIP-7702 + ERC-4337) Integration
Both Viem and Wagmi are viable choices for building a MetaMask-enabled front end with Account Abstraction. In fact, MetaMask’s own Smart Accounts tooling and Pimlico’s paymaster SDK support both libraries. However, they serve different needs:
•	Viem is a low-level TypeScript Ethereum client (now used internally by Wagmi) that offers direct control over signing and transactions, including built-in Account Abstraction helpers.
•	Wagmi is a higher-level React hooks library that simplifies wallet connectivity and state management (using Viem under the hood). It doesn’t natively construct UserOperations or EIP-7702 authorizations, but it integrates easily with MetaMask’s flows and can leverage add-ons (like Pimlico’s Permissionless SDK) to handle AA details.
Below we break down support and compatibility in key areas, then recommend an approach.
Official Support & Integration
•	MetaMask Smart Accounts Kit: MetaMask’s toolkit for smart accounts is built around Viem. Their EIP-7702 quickstart uses Viem exclusively for creating clients, signing the 7702 authorization, and sending UserOperations[1][2]. The kit even notes it’s “a Viem-based toolkit”[3]. In code samples, MetaMask calls Viem’s signAuthorization to upgrade an EOA (this requires direct key access, since signAuthorization “does not support JSON-RPC accounts” like the injected MetaMask provider)[4]. They also use Viem’s createBundlerClient and sendUserOperation for ERC-4337 flows[5][6].
That said, MetaMask does support Wagmi-based apps as first-class citizens. In fact, MetaMask’s August 2025 tutorial for upgrading an EOA uses a Next.js + Wagmi template[7]. They provide a Wagmi connector for the MetaMask SDK (which bridges to the extension or mobile)[8] and demonstrate using Wagmi hooks (useAccount, useConnect, etc.) to connect the wallet[9][10]. When the dApp attempts an AA-specific action (like sending a batch transaction via EIP-5792), the MetaMask extension automatically prompts the user to upgrade their EOA to a smart account before proceeding[11]. This shows MetaMask’s native integration with Wagmi + MetaMask SDK: the wallet itself handles the EIP-7702 upgrade in the UI flow. Wagmi didn’t require any custom code to trigger this – the extension recognized the batch request and handled the 7702 logic internally.
Bottom line – MetaMask’s official stance: You can use either library. Viem is directly utilized in their Smart Accounts Kit for programmatic control[1][2]. Meanwhile, Wagmi is “plug-and-play” for frontends – MetaMask notes that no special setup is needed to use a smart account signer with Wagmi hooks[12]. Wagmi’s useAccount will simply report the smart contract account address once the wallet is upgraded[13]. And MetaMask specifically built a Wagmi connector for their SDK[8], showing strong support.
•	Pimlico (Paymaster & Permissionless.js): Pimlico’s tooling is similarly agnostic and supports both Wagmi and Viem. Their permissionless.js library is built as a thin layer on top of Viem and Wagmi[14] to simplify ERC-4337 development. Pimlico explicitly chose to reuse these popular libraries rather than force a new framework[15]. In practice, you have two options:
•	Use @permissionless/core (which uses Viem clients under the hood) directly for building UserOps, managing bundlers/paymasters, etc.
•	Use @permissionless/wagmi, a drop-in replacement around Wagmi hooks that adds account-abstraction features. This wrapper makes enabling gas sponsorship and batching very easy for React apps – you just wrap your app with \<PermissionlessProvider\> and then call useSendTransaction as usual[16][17]. Under the hood, it will handle injecting the paymaster info and batching logic. The API mirrors Wagmi’s, preserving the developer experience[18]. (For example, calling sendTransaction via @permissionless/wagmi will actually create and send a UserOperation with gas paid by a paymaster[19][20].)
Pimlico’s support: Since Permissionless is built on Viem’s foundations, using Viem directly gives you full access to its features. But Pimlico clearly anticipated that many projects use Wagmi – they created @permissionless/wagmi specifically to cater to Wagmi/React developers, indicating strong support for that path[21][18]. In short, you won’t be locked out of Pimlico’s gas sponsorship whether you choose Wagmi or Viem – they provide tools for both.
EIP-7702 Signer Compatibility (Stateless Smart Accounts)
EIP-7702 (“Stateless Smart Accounts”) allows an EOA to attach contract code to itself (upgrading to a smart contract wallet) without a separate deployment[4]. The “signer requirements” here refer to how the EOA authorizes that upgrade. Viem’s walletClient.signAuthorization can craft the required EIP-712 signature for the delegator contract, but (as noted) it can’t use an injected provider for this[4]. This implies that if you as a dApp developer want to programmatically initiate a 7702 upgrade, you’d need the user’s private key or a signing method beyond standard RPC – not practical with just MetaMask’s window.ethereum.
How to handle 7702 in practice:
•	Via MetaMask UI: The simplest route is to let MetaMask handle it. As seen in MetaMask’s tutorial, if you request a batch or sponsored transaction through the MetaMask SDK, the extension will guide the user through the upgrade (with proper confirmation UI)[11]. This is ideal for security and UX. In this scenario, Wagmi (with the MetaMask SDK connector) is very compatible – you don’t manually call signAuthorization at all. You just call useSendCalls or similar, and MetaMask does the heavy lifting behind the scenes[11]. Wagmi already supports the new wallet_getCapabilities RPC and related hooks to detect smart account features (MetaMask and others use this for 7702)[22], meaning it’s up-to-date with MetaMask’s requirements.
•	Via custom code: If you needed to trigger the 7702 delegation yourself (say, in a custom wallet scenario or a script), Viem is the better tool. Using Viem, you can directly call signAuthorization and sendTransaction({ authorizationList: [...] }) to set the account code[23][24]. This is exactly what the Smart Accounts Kit does in its quickstart. Wagmi by itself does not expose a function to attach an authorization to a transaction – you would have to drop down to a lower level (e.g. get the walletClient from Wagmi and call Viem or Permissionless functions). In a Wagmi app, you can do this: for example, using useWalletClient to retrieve the Viem client for the MetaMask signer, then calling kit methods or Permissionless functions on it. But it’s an extra step outside Wagmi’s abstractions.
Summary: If you plan to rely on MetaMask’s built-in flow for EIP-7702 (recommended for user-triggered upgrades), Wagmi works seamlessly. If you need granular control to craft the 7702 transaction yourself, Viem (or MetaMask’s kit, which is Viem-based) gives you the necessary low-level access[4][24].
Building & Signing UserOperations (ERC-4337)
ERC-4337 UserOperations can be constructed and sent either by your frontend or by the wallet. Key considerations:
•	MetaMask’s approach: When using MetaMask’s Smart Account, you often don’t manually build the UserOp – the MetaMask AA provider will do it. For example, with Web3Auth’s AA Provider (used in MetaMask’s embedded wallets), developers just call sendTransaction with to/data/value, and the provider turns it into a UserOp under the hood[25]. MetaMask notes that any extra fields (gas, nonce, etc.) are overridden automatically[25]. In Wagmi, you can simply use useSendTransaction or even signer.sendTransaction and it will translate to a UserOperation if the account is a smart account[25][26]. This is very developer-friendly – you don’t worry about the UserOp structure at all in your React code.
If you do need to customize the UserOperation (say to tweak gas or use a specific paymaster manually), MetaMask suggests using Viem’s BundlerClient to construct/send it[25]. Viem exposes bundlerClient.sendUserOperation which accepts a UserOperation or simplified params (account, calls, gas params, etc.)[2][27]. With Viem, you have full flexibility to build complex UserOps (batch multiple calls, set custom paymaster data, etc.). Wagmi by itself doesn’t have an API for “sendUserOperation” – it relies on the wallet’s implementation. So for advanced control in a Wagmi app, again you’d interop with a lower-level library (either Viem or Pimlico’s Permissionless API) to send the op.
•	Pimlico’s approach: Permissionless.js gives a high-level way to create UserOps with paymasters. If using @permissionless/wagmi, your calls to useSendTransaction automatically include the configured paymaster (like Pimlico’s) and go to a bundler[20][18]. This makes gasless transactions trivial in a Wagmi context – essentially a one-line change to swap Wagmi’s hook to Permissionless’s hook, plus passing your Pimlico API key in the provider setup. Underneath, Permissionless is using Viem’s client to build the UserOp and call the bundler, but you don’t have to see that.
If you prefer not to use the wrapper, you could use Permissionless core (or even direct bundler RPC calls via Viem) in a Viem-based app. For example, you can manually construct a UserOperation object, sign it with the account’s key, and call the bundler’s eth_sendUserOperation. Viem helps here by providing typed utilities for the UserOp structure and signing. But going that low-level means more code and keeping up with spec details.
Summary: For most DApps, Wagmi (with MetaMask’s or Pimlico’s integrations) is sufficient – you can initiate transactions normally and let the underlying provider/SDK handle the UserOp creation. This covers the common “gasless tx via paymaster” use-case with minimal effort. If you need to explicitly build or manipulate UserOps (custom flows, debugging, non-standard usage), Viem offers direct APIs to do so[27]. In a Wagmi app you’re not locked out – you can obtain the Viem publicClient and walletClient from Wagmi’s hooks[28] – but it’s more work than using the turnkey approach.
Browser Compatibility (Vite/Next.js)
Both libraries are compatible with modern frontend tooling:
•	Wagmi is built for React (it supports Next.js and Vite/CRA apps). It works on the client side; for Next.js, you’ll mark Wagmi components as client components. The MetaMask Next.js template confirms Wagmi works well in that environment[7]. Many projects use Wagmi with Vite (which is just a dev server/bundler) without issue. There is no heavy Node dependency – Wagmi’s underlying JSON-RPC calls are via Viem which uses fetch.
•	Viem is framework-agnostic. You can use it in a React app or even outside of React (in plain JS/TS). It’s tree-shakable and lightweight. If you are in a Next.js app but perhaps want to perform some server-side blockchain queries (without a wallet), Viem can run on server too. However, for wallet integration in the browser, you’d typically use Viem’s createWalletClient({ transport: custom(window.ethereum) }) to wrap MetaMask’s provider[29]. This works in the browser environment, including Vite dev server or Next’s client side. There’s no fundamental compatibility issue with either – it’s more about whether you need React hooks. If your project is indeed a React UI, Wagmi will slot in naturally; if it’s a non-React JS app, Viem would be the direct choice.
Real-World Usage Examples
•	MetaMask’s Smart Account Quickstart (Sepolia testnet) – uses Viem + Smart Accounts Kit. It demonstrates upgrading an EOA via 7702 and sending a UserOp through a bundler[4][27]. This example is more “under the hood” and is great for understanding the mechanics. But it uses a private key directly for signing (not the MetaMask extension) – meaning it’s oriented to dev/test scenarios or custom custodial flows.
•	MetaMask’s Upgrade & Batch TX Tutorial – uses Wagmi + MetaMask SDK. This is a template for a Next.js app where the user connects their MetaMask and the dApp can request batch transactions. The user experience is smooth: clicking “Send Batch” triggers MetaMask to ask for an upgrade and then a sponsored batch send[11]. Internally, this leverages Infura’s bundler and a Pimlico paymaster (MetaMask’s default setup) without the developer writing AA logic. It highlights Wagmi’s strength in quick integration.
•	Pimlico’s Permissionless – shows both approaches in action. For instance, their tutorials demonstrate using @permissionless/wagmi in a React app to send a gasless transaction with just a few lines of code (essentially swapping Wagmi’s provider and hooks for the Permissionless-enhanced ones)[16][20]. They also have examples using the core viem-based API for more custom scenarios. The fact that Pimlico provides a Wagmi adapter implies that many devs building AA frontends prefer the Wagmi pattern.
•	Others (Biconomy, ZeroDev, etc.): Competing AA providers also often show Wagmi+Viem combos. For example, Biconomy’s docs (SDK v3) showed how to use Wagmi hooks to get a Viem walletClient and then pass it into their AA SDK[30][31]. ZeroDev has noted that “Viem and Wagmi already support wallet_getCapabilities” for detecting AA features, underscoring that both libraries are keeping up with new standards[32][22].
Pros and Cons Summary
Wagmi (with MetaMask SDK or Permissionless):
•	Pros: Easiest way to integrate MetaMask in a React app; provides out-of-the-box hooks for connection (useConnect, useAccount) and transactions (useSendTransaction, etc.). No need to reinvent UI state management. MetaMask’s smart accounts are fully compatible – you use Wagmi “like a regular EOA” signer[33] and MetaMask/Permissionless handle the AA behind scenes. Official examples and community docs heavily feature Wagmi, meaning lots of guidance. Also, Permissionless’s Wagmi plugin can enable gasless and batch features with minimal changes[21][17]. Browser support in frameworks like Next.js and Vite is well-established.
•	Cons: Wagmi by itself abstracts away the details – which is usually good, but if you need to do something custom, you might have to drop to a lower-level API. For instance, there is no Wagmi hook for “signAuthorization for 7702” or “build UserOp and send to custom bundler.” You’d integrate an additional library (MetaMask’s kit, or Permissionless, or even raw Viem calls) for those. This isn’t a huge drawback (since those libraries interop well), but it means Wagmi is not a one-stop solution for every AA edge-case. Also, Wagmi is React-specific; if you ever needed to do AA actions outside React (say, in a Node script or backend), you’d use Viem or an SDK instead.
Viem:
•	Pros: Full control over Ethereum interactions with first-class support for Account Abstraction. You can directly query the wallet’s capabilities, sign 7702 authorizations, construct UserOps, specify paymaster data, etc. MetaMask’s tooling uses Viem under the hood, so you’re working at the “source of truth.” Viem’s TypeScript types for UserOperations and accounts reduce errors when dealing with these new EIPs. It’s also lightweight and can be used anywhere (client, server, scripts). If your app isn’t using React, Viem is clearly the better fit (Wagmi wouldn’t apply).
•	Cons: Being lower-level, you write more boilerplate. You’ll need to manage connecting to MetaMask (e.g. using window.ethereum as a custom transport) and updating UI state manually or via your own context/store. In React apps, that means you’d either write a lot of useEffect/useState logic or pair Viem with another state library. Essentially, you might end up recreating some of Wagmi’s wheel. Additionally, while Viem is very well-maintained, the ecosystem examples (blogs, templates) tend to be a bit more sparse compared to Wagmi’s – many tutorials assume Wagmi for frontends and Viem for under-the-hood logic. That said, the learning curve for basic Viem usage is not steep if you’re comfortable with TypeScript.
Recommendation
For a browser-based frontend (Vite/Next.js) that needs MetaMask integration with EIP-7702 and gasless ERC-4337 transactions, using Wagmi is generally the most developer-friendly approach – with Viem and/or MetaMask’s kit working behind the scenes. Wagmi will handle the wallet connection UX and reactively track the user’s account (which becomes the smart account after upgrade)[13]. It aligns with MetaMask’s own examples and will automatically leverage MetaMask’s built-in AA features (like prompting the 7702 upgrade when needed)[11]. For gasless transactions, you can easily integrate a paymaster via Pimlico’s @permissionless/wagmi or by configuring MetaMask’s AA provider to use Pimlico’s service – either way, you’re writing very little extra code to get gas fees sponsored.
Viem is still crucial – and you won’t be ignoring it even if you choose Wagmi. Under the hood, Wagmi uses Viem for all RPC calls, and you can drop down to Viem’s clients whenever you need more control. If your application demands custom AA logic (batches, multi-paymaster support, etc.), you might write a small utility with Viem’s BundlerClient to submit those ops[25], or use MetaMask’s Smart Accounts Kit directly alongside your Wagmi hooks. This hybrid approach is common: for instance, you might use Wagmi’s useWalletClient() to get a Viem wallet client and then call smartAccountsKit.toMetaMaskSmartAccount() to obtain a SmartAccount object in code[34]. In short, Wagmi and Viem aren’t mutually exclusive – they complement each other.
However, if you prefer not to use React hooks at all (or you want maximum control and are comfortable managing state), you could build with Viem alone. You would manually interact with window.ethereum, call viem.sendUserOperation or Permissionless functions, and handle user prompts via MetaMask’s RPC methods. This gives you ultimate flexibility and aligns 100% with MetaMask’s low-level toolkit[4][27]. Just be prepared to implement more UI logic yourself.
In summary: For most developers building a modern web dApp, Wagmi is the more convenient choice for MetaMask AA integration, thanks to its high-level support and official endorsements from MetaMask and Pimlico. It simplifies the common tasks and keeps your codebase lean, especially when combined with tools like MetaMask’s SDK or Permissionless.js for gasless features. Viem is the better choice if you need to go beyond what Wagmi abstracts – and fortunately, even in a Wagmi app you can leverage Viem whenever needed.
Given that you are building a frontend and likely want to focus on UX rather than fiddling with raw transactions, our recommendation is to start with Wagmi (plus MetaMask’s AA SDK or Pimlico’s wagmi plugin for paymasters). This will cover MetaMask + EIP-7702 + ERC-4337 “gasless” flows with minimal friction. Keep Viem in your toolbox for any advanced customization – its integration is natural since Wagmi uses Viem under the hood.
Pros & Cons Recap:
•	Wagmi – Pros: High-level React integration, easy MetaMask connectivity, smart accounts work out-of-box[12], hooks for transactions (including batch via useSendCalls[11]), large community and examples, easy paymaster integration via Permissionless. Cons: Requires React, and for custom AA actions you’ll use additional libraries (Permissionless or Viem directly) since Wagmi’s core doesn’t manually compose UserOps.
•	Viem – Pros: First-class support for 4337/7702 in code (signing, bundlers, etc.), used by official kits[4][27], not tied to any framework. Cons: Lower-level – you handle more yourself (no built-in UI hooks), and MetaMask extension’s special flows (like prompting upgrade) aren’t automagic unless you use MetaMask’s SDK or Wallet API calls on top of Viem.
In conclusion, for a typical React/Vite/Next frontend, Wagmi gets the nod with strong backing from both MetaMask and Pimlico. You’ll benefit from its simplicity and growing AA capabilities, and you won’t be limited if you need to dip into Viem for advanced features. Use Wagmi for the 90% case, and Viem when you need that extra 10% of control[25]. This combination will give you a well-supported, future-proof integration for MetaMask Smart Accounts with gasless transactions.
________________________________________
[1] [2] [4] [5] [6] [23] [24] [27] [34] EIP-7702 quickstart | MetaMask developer documentation
https://docs.metamask.io/smart-accounts-kit/get-started/smart-account-quickstart/eip7702/
[3] GitHub - MetaMask/smart-accounts-kit: A Viem-based Toolkit for integrating embedded smart contract wallets into dapps.
https://github.com/MetaMask/smart-accounts-kit
[7] [8] [9] [10] [11] Upgrade an EOA to a smart account | MetaMask developer documentation
https://docs.metamask.io/tutorials/upgrade-eoa-to-smart-account/
[12] [13] [25] [26] [29] [33] Smart Accounts | MetaMask developer documentation
https://docs.metamask.io/embedded-wallets/sdk/react/advanced/smart-accounts/
[14] [15] Why permissionless.js | Pimlico Docs
https://docs.pimlico.io/references/permissionless/why
[16] [17] [18] [19] [20] [21] permissionless.js | Pimlico Docs
https://docs.pimlico.io/references/permissionless/wagmi
[22] “Luckily, Viem and Wagmi already support wallet_getCapabilities ...
https://x.com/alexanderchopan/status/1901501262291435712
[28] GitHub - zt-9/wagmi-erc4337
https://github.com/zt-9/wagmi-erc4337
[30] [31] Create Smart Accounts with WAGMI React Hooks | Biconomy
https://legacy-docs.biconomy.io/3.0/account/signers/eoa/wagmi
[32] Native Smart Accounts | MetaMask developer documentation
https://docs.metamask.io/embedded-wallets/features/smart-accounts/

------------------------------------------------------------------

